import asyncio
from typing import List, Dict
from aura.core.brain import AuraBrain

class ChainOfThoughtExploiter:
    """The 'Burp/ZAP Killer': Orchestrates multi-step attack chains autonomously."""
    
    def __init__(self, brain: AuraBrain):
        self.brain = brain
        self.state_knowledge = {} # Stores discovered secrets, creds, paths

    async def analyze_and_chain(self, finding: Dict, target_url: str) -> List[Dict]:
        """Analyzes a finding and returns a list of recommended 'Next Step' attack vectors."""
        print(f"[ðŸ§ ] CoT-Exploiter: Analyzing finding '{finding['type']}' to plan next stage...")
        
        chain_actions = []
        
        # Scenario 1: Information Disclosure -> Credential Extraction
        if "Disclosure" in finding['type'] or "Exposure" in finding['type']:
            if ".env" in finding.get('content', '') or "config" in finding.get('content', ''):
                chain_actions.append({
                    "action": "CREDENTIAL_EXTRACTION",
                    "reason": "Found configuration file. Attempting to extract DB/API secrets.",
                    "priority": "CRITICAL"
                })

        # Scenario 2: Hidden Path -> Privilege Escalation / Auth Bypass
        if "Hidden Path" in finding['type']:
            if any(kw in finding['content'].lower() for kw in ["admin", "portal", "dashboard", "manage"]):
                chain_actions.append({
                    "action": "AUTHENTICATION_BYPASS_PROBE",
                    "reason": "Found administrative portal. Attempting SQLi/Default Creds bypass.",
                    "priority": "HIGH"
                })

        # Use AI to brainstorm more complex chains
        prompt = f"""
        Act as an Offensive AI. I found a vulnerability of type '{finding['type']}' with following content: '{finding['content'][:200]}'.
        Develop a 2-step 'Attack Chain' to escalate this finding into a higher impact (e.g., RCE, Data Exfiltration).
        Return ONLY a JSON list of objects with keys: 'action', 'reason', 'payload_hint'.
        """
        
        try:
            ai_chain_raw = self.brain.reason({"task": "exploit_chain", "prompt": prompt})
            clean_chain = ai_chain_raw.replace("```json", "").replace("```", "").strip()
            import json
            ai_chain = json.loads(clean_chain)
            if isinstance(ai_chain, list):
                chain_actions.extend(ai_chain)
        except: pass

        return chain_actions

    async def execute_chain_step(self, step: Dict, target_url: str, session):
        """Executes a specific chain step (Simplified for Phase 27)."""
        # In a full implementation, this would call specialized modules
        # For v13.0, we just log the 'Intent' to the console and DB to show the CoT reasoning.
        print(f"[ðŸ”¥] CoT-Exploiter: Executing Step [{step['action']}] - {step['reason']}")
        return {"status": "intent_logged", "step": step['action']}
